
i2cLedTest.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000087a  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00802000  00802000  000008ee  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000016d  00802000  00802000  000008ee  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000008ee  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000920  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000160  00000000  00000000  00000960  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000171f  00000000  00000000  00000ac0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000861  00000000  00000000  000021df  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000008be  00000000  00000000  00002a40  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000031c  00000000  00000000  00003300  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000a2c  00000000  00000000  0000361c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000b22  00000000  00000000  00004048  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000208  00000000  00000000  00004b6a  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 00 01 	jmp	0x200	; 0x200 <__ctors_end>
   4:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
   8:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
   c:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
  10:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
  14:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
  18:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
  1c:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
  20:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
  24:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
  28:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
  2c:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
  30:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
  34:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
  38:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
  3c:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
  40:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
  44:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
  48:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
  4c:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
  50:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
  54:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
  58:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
  5c:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
  60:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
  64:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
  68:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
  6c:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
  70:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
  74:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
  78:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
  7c:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
  80:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
  84:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
  88:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
  8c:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
  90:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
  94:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
  98:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
  9c:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
  a0:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
  a4:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
  a8:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
  ac:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
  b0:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
  b4:	0c 94 5b 01 	jmp	0x2b6	; 0x2b6 <__vector_45>
  b8:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
  bc:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
  c0:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
  c4:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
  c8:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
  cc:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
  d0:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
  d4:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
  d8:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
  dc:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
  e0:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
  e4:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
  e8:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
  ec:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
  f0:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
  f4:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
  f8:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
  fc:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
 100:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
 104:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
 108:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
 10c:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
 110:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
 114:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
 118:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
 11c:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
 120:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
 124:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
 128:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
 12c:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
 130:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
 134:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
 138:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
 13c:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
 140:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
 144:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
 148:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
 14c:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
 150:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
 154:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
 158:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
 15c:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
 160:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
 164:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
 168:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
 16c:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
 170:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
 174:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
 178:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
 17c:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
 180:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
 184:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
 188:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
 18c:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
 190:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
 194:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
 198:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
 19c:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
 1a0:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
 1a4:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
 1a8:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
 1ac:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
 1b0:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
 1b4:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
 1b8:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
 1bc:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
 1c0:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
 1c4:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
 1c8:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
 1cc:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
 1d0:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
 1d4:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
 1d8:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
 1dc:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
 1e0:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
 1e4:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
 1e8:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
 1ec:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
 1f0:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
 1f4:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>
 1f8:	0c 94 14 01 	jmp	0x228	; 0x228 <__bad_interrupt>

000001fc <__trampolines_start>:
 1fc:	0c 94 16 01 	jmp	0x22c	; 0x22c <TWIC_SlaveProcessData>

00000200 <__ctors_end>:
 200:	11 24       	eor	r1, r1
 202:	1f be       	out	0x3f, r1	; 63
 204:	cf ef       	ldi	r28, 0xFF	; 255
 206:	cd bf       	out	0x3d, r28	; 61
 208:	df e5       	ldi	r29, 0x5F	; 95
 20a:	de bf       	out	0x3e, r29	; 62
 20c:	00 e0       	ldi	r16, 0x00	; 0
 20e:	0c bf       	out	0x3c, r16	; 60

00000210 <__do_clear_bss>:
 210:	21 e2       	ldi	r18, 0x21	; 33
 212:	a0 e0       	ldi	r26, 0x00	; 0
 214:	b0 e2       	ldi	r27, 0x20	; 32
 216:	01 c0       	rjmp	.+2      	; 0x21a <.do_clear_bss_start>

00000218 <.do_clear_bss_loop>:
 218:	1d 92       	st	X+, r1

0000021a <.do_clear_bss_start>:
 21a:	ad 36       	cpi	r26, 0x6D	; 109
 21c:	b2 07       	cpc	r27, r18
 21e:	e1 f7       	brne	.-8      	; 0x218 <.do_clear_bss_loop>
 220:	0e 94 f8 03 	call	0x7f0	; 0x7f0 <main>
 224:	0c 94 3b 04 	jmp	0x876	; 0x876 <_exit>

00000228 <__bad_interrupt>:
 228:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000022c <TWIC_SlaveProcessData>:

//This is what happens whenever a new byte is received 
static void TWIC_SlaveProcessData(void)
{
	//PORTD.OUT = twiSlave.receivedData[twiSlave.bytesReceived];
	queue_enQueue(twiSlave.receivedData[twiSlave.bytesReceived]);
 22c:	e0 91 68 21 	lds	r30, 0x2168
 230:	f0 e0       	ldi	r31, 0x00	; 0
 232:	e8 5b       	subi	r30, 0xB8	; 184
 234:	fe 4d       	sbci	r31, 0xDE	; 222
 236:	84 81       	ldd	r24, Z+4	; 0x04
 ********************/

//Places data at head, increments head
static void queue_enQueue(uint8_t data)
{
	byteQueue.dataArray[byteQueue.head] = data;
 238:	a4 e0       	ldi	r26, 0x04	; 4
 23a:	b1 e2       	ldi	r27, 0x21	; 33
 23c:	ec 91       	ld	r30, X
 23e:	f0 e0       	ldi	r31, 0x00	; 0
 240:	ec 5f       	subi	r30, 0xFC	; 252
 242:	fe 4d       	sbci	r31, 0xDE	; 222
 244:	83 83       	std	Z+3, r24	; 0x03
	byteQueue.head++;
 246:	8c 91       	ld	r24, X
 248:	8f 5f       	subi	r24, 0xFF	; 255
 24a:	8c 93       	st	X, r24
	if(byteQueue.head == BYTE_ARRAY_SIZE)
 24c:	8c 91       	ld	r24, X
 24e:	80 34       	cpi	r24, 0x40	; 64
 250:	11 f4       	brne	.+4      	; 0x256 <TWIC_SlaveProcessData+0x2a>
	{
		byteQueue.head = 0;
 252:	10 92 04 21 	sts	0x2104, r1
	}

	if(byteQueue.numData < BYTE_ARRAY_SIZE)
 256:	80 91 06 21 	lds	r24, 0x2106
 25a:	80 34       	cpi	r24, 0x40	; 64
 25c:	30 f4       	brcc	.+12     	; 0x26a <TWIC_SlaveProcessData+0x3e>
	{
		byteQueue.numData++;
 25e:	e4 e0       	ldi	r30, 0x04	; 4
 260:	f1 e2       	ldi	r31, 0x21	; 33
 262:	82 81       	ldd	r24, Z+2	; 0x02
 264:	8f 5f       	subi	r24, 0xFF	; 255
 266:	82 83       	std	Z+2, r24	; 0x02
 268:	08 95       	ret
	}
	else
	{
		byteQueue.overflowFlag = 1;
 26a:	e4 e0       	ldi	r30, 0x04	; 4
 26c:	f1 e2       	ldi	r31, 0x21	; 33
 26e:	81 e0       	ldi	r24, 0x01	; 1
 270:	80 93 47 21 	sts	0x2147, r24
		byteQueue.tail++;
 274:	81 81       	ldd	r24, Z+1	; 0x01
 276:	8f 5f       	subi	r24, 0xFF	; 255
 278:	81 83       	std	Z+1, r24	; 0x01
		if(byteQueue.tail == BYTE_ARRAY_SIZE)
 27a:	81 81       	ldd	r24, Z+1	; 0x01
 27c:	80 34       	cpi	r24, 0x40	; 64
 27e:	11 f4       	brne	.+4      	; 0x284 <TWIC_SlaveProcessData+0x58>
		{
			byteQueue.tail = 0;
 280:	10 92 05 21 	sts	0x2105, r1
 284:	08 95       	ret

00000286 <byteQueue_deQueue>:


//Returns data at tail, increments tail
static uint8_t byteQueue_deQueue()
{
	if(byteQueue.numData == 0)
 286:	80 91 06 21 	lds	r24, 0x2106
 28a:	88 23       	and	r24, r24
 28c:	99 f0       	breq	.+38     	; 0x2b4 <byteQueue_deQueue+0x2e>
	{
		return 0;
	}
	byteQueue.numData--;
 28e:	e4 e0       	ldi	r30, 0x04	; 4
 290:	f1 e2       	ldi	r31, 0x21	; 33
 292:	82 81       	ldd	r24, Z+2	; 0x02
 294:	81 50       	subi	r24, 0x01	; 1
 296:	82 83       	std	Z+2, r24	; 0x02

	uint8_t dataToReturn = byteQueue.dataArray[byteQueue.tail];
 298:	a1 81       	ldd	r26, Z+1	; 0x01
 29a:	b0 e0       	ldi	r27, 0x00	; 0
 29c:	ac 5f       	subi	r26, 0xFC	; 252
 29e:	be 4d       	sbci	r27, 0xDE	; 222
 2a0:	13 96       	adiw	r26, 0x03	; 3
 2a2:	8c 91       	ld	r24, X
	byteQueue.tail++;
 2a4:	91 81       	ldd	r25, Z+1	; 0x01
 2a6:	9f 5f       	subi	r25, 0xFF	; 255
 2a8:	91 83       	std	Z+1, r25	; 0x01
	if(byteQueue.tail == BYTE_ARRAY_SIZE)
 2aa:	91 81       	ldd	r25, Z+1	; 0x01
 2ac:	90 34       	cpi	r25, 0x40	; 64
 2ae:	11 f4       	brne	.+4      	; 0x2b4 <byteQueue_deQueue+0x2e>
	{
		byteQueue.tail = 0;
 2b0:	10 92 05 21 	sts	0x2105, r1
	}

	return dataToReturn;
}
 2b4:	08 95       	ret

000002b6 <__vector_45>:
static volatile struct queueData byteQueue;
static struct packetQueueData packetQueue;

// TWIE Slave Interrupt vector.
ISR(TWIE_TWIS_vect)
{
 2b6:	1f 92       	push	r1
 2b8:	0f 92       	push	r0
 2ba:	0f b6       	in	r0, 0x3f	; 63
 2bc:	0f 92       	push	r0
 2be:	11 24       	eor	r1, r1
 2c0:	0b b6       	in	r0, 0x3b	; 59
 2c2:	0f 92       	push	r0
 2c4:	2f 93       	push	r18
 2c6:	3f 93       	push	r19
 2c8:	4f 93       	push	r20
 2ca:	5f 93       	push	r21
 2cc:	6f 93       	push	r22
 2ce:	7f 93       	push	r23
 2d0:	8f 93       	push	r24
 2d2:	9f 93       	push	r25
 2d4:	af 93       	push	r26
 2d6:	bf 93       	push	r27
 2d8:	ef 93       	push	r30
 2da:	ff 93       	push	r31
	TWI_SlaveInterruptHandler(&twiSlave);
 2dc:	88 e4       	ldi	r24, 0x48	; 72
 2de:	91 e2       	ldi	r25, 0x21	; 33
 2e0:	0e 94 c9 03 	call	0x792	; 0x792 <TWI_SlaveInterruptHandler>
}
 2e4:	ff 91       	pop	r31
 2e6:	ef 91       	pop	r30
 2e8:	bf 91       	pop	r27
 2ea:	af 91       	pop	r26
 2ec:	9f 91       	pop	r25
 2ee:	8f 91       	pop	r24
 2f0:	7f 91       	pop	r23
 2f2:	6f 91       	pop	r22
 2f4:	5f 91       	pop	r21
 2f6:	4f 91       	pop	r20
 2f8:	3f 91       	pop	r19
 2fa:	2f 91       	pop	r18
 2fc:	0f 90       	pop	r0
 2fe:	0b be       	out	0x3b, r0	; 59
 300:	0f 90       	pop	r0
 302:	0f be       	out	0x3f, r0	; 63
 304:	0f 90       	pop	r0
 306:	1f 90       	pop	r1
 308:	18 95       	reti

0000030a <i2cAPI_init>:
/************************
 * Non-static functions *
 ************************/

void i2cAPI_init(uint8_t addressP)
{
 30a:	cf 93       	push	r28
 30c:	c8 2f       	mov	r28, r24
	//Initialize TWI slave on Port E
	TWI_SlaveInitializeDriver(&twiSlave, &TWIE, TWIC_SlaveProcessData);
 30e:	46 e1       	ldi	r20, 0x16	; 22
 310:	51 e0       	ldi	r21, 0x01	; 1
 312:	60 ea       	ldi	r22, 0xA0	; 160
 314:	74 e0       	ldi	r23, 0x04	; 4
 316:	88 e4       	ldi	r24, 0x48	; 72
 318:	91 e2       	ldi	r25, 0x21	; 33
 31a:	0e 94 07 03 	call	0x60e	; 0x60e <TWI_SlaveInitializeDriver>
	TWI_SlaveInitializeModule(&twiSlave, addressP, TWI_SLAVE_INTLVL_LO_gc);
 31e:	40 e4       	ldi	r20, 0x40	; 64
 320:	6c 2f       	mov	r22, r28
 322:	88 e4       	ldi	r24, 0x48	; 72
 324:	91 e2       	ldi	r25, 0x21	; 33
 326:	0e 94 12 03 	call	0x624	; 0x624 <TWI_SlaveInitializeModule>
}
 32a:	cf 91       	pop	r28
 32c:	08 95       	ret

0000032e <i2cAPI_checkForPackets>:

void i2cAPI_checkForPackets()
{
 32e:	5f 92       	push	r5
 330:	6f 92       	push	r6
 332:	7f 92       	push	r7
 334:	8f 92       	push	r8
 336:	9f 92       	push	r9
 338:	af 92       	push	r10
 33a:	bf 92       	push	r11
 33c:	cf 92       	push	r12
 33e:	df 92       	push	r13
 340:	ef 92       	push	r14
 342:	ff 92       	push	r15
 344:	0f 93       	push	r16
 346:	1f 93       	push	r17
 348:	cf 93       	push	r28
 34a:	df 93       	push	r29
 34c:	cd b7       	in	r28, 0x3d	; 61
 34e:	de b7       	in	r29, 0x3e	; 62
 350:	64 97       	sbiw	r28, 0x14	; 20
 352:	cd bf       	out	0x3d, r28	; 61
 354:	de bf       	out	0x3e, r29	; 62
}

//returns how many items are in the queue
static volatile uint8_t i2c_hasData()
{
	return byteQueue.numData;
 356:	80 91 06 21 	lds	r24, 0x2106

void i2cAPI_checkForPackets()
{
	//uint8_t pathTrace = 0;
	//uint8_t timedOut = 0;
	if(i2c_hasData())
 35a:	88 23       	and	r24, r24
 35c:	09 f4       	brne	.+2      	; 0x360 <i2cAPI_checkForPackets+0x32>
 35e:	f7 c0       	rjmp	.+494    	; 0x54e <i2cAPI_checkForPackets+0x220>
 360:	fe 01       	movw	r30, r28
 362:	31 96       	adiw	r30, 0x01	; 1
 364:	ce 01       	movw	r24, r28
 366:	45 96       	adiw	r24, 0x15	; 21
		//pathTrace++;
		uint8_t success = 0;
		uint8_t receiveArray[RECEIVE_ARRAY_SIZE];
		for(int i = 0; i < RECEIVE_ARRAY_SIZE; i++)
		{
			receiveArray[i] = 0x00;
 368:	11 92       	st	Z+, r1
	if(i2c_hasData())
	{
		//pathTrace++;
		uint8_t success = 0;
		uint8_t receiveArray[RECEIVE_ARRAY_SIZE];
		for(int i = 0; i < RECEIVE_ARRAY_SIZE; i++)
 36a:	e8 17       	cp	r30, r24
 36c:	f9 07       	cpc	r31, r25
 36e:	e1 f7       	brne	.-8      	; 0x368 <i2cAPI_checkForPackets+0x3a>
}

//returns how many items are in the queue
static volatile uint8_t i2c_hasData()
{
	return byteQueue.numData;
 370:	80 91 06 21 	lds	r24, 0x2106
		uint8_t receiveArray[RECEIVE_ARRAY_SIZE];
		for(int i = 0; i < RECEIVE_ARRAY_SIZE; i++)
		{
			receiveArray[i] = 0x00;
		}
		while(i2c_hasData() && (receiveArray[0] != START) )
 374:	88 23       	and	r24, r24
 376:	09 f4       	brne	.+2      	; 0x37a <i2cAPI_checkForPackets+0x4c>
 378:	d4 c0       	rjmp	.+424    	; 0x522 <i2cAPI_checkForPackets+0x1f4>
 37a:	89 81       	ldd	r24, Y+1	; 0x01
 37c:	8b 3a       	cpi	r24, 0xAB	; 171
 37e:	69 f0       	breq	.+26     	; 0x39a <i2cAPI_checkForPackets+0x6c>
}

//returns how many items are in the queue
static volatile uint8_t i2c_hasData()
{
	return byteQueue.numData;
 380:	04 e0       	ldi	r16, 0x04	; 4
 382:	11 e2       	ldi	r17, 0x21	; 33
	return dataToReturn;
}

static uint8_t i2c_getByte()
{
	return byteQueue_deQueue();
 384:	0e 94 43 01 	call	0x286	; 0x286 <byteQueue_deQueue>
		{
			receiveArray[i] = 0x00;
		}
		while(i2c_hasData() && (receiveArray[0] != START) )
		{
			receiveArray[0] = i2c_getByte();
 388:	89 83       	std	Y+1, r24	; 0x01
}

//returns how many items are in the queue
static volatile uint8_t i2c_hasData()
{
	return byteQueue.numData;
 38a:	d8 01       	movw	r26, r16
 38c:	12 96       	adiw	r26, 0x02	; 2
 38e:	9c 91       	ld	r25, X
		uint8_t receiveArray[RECEIVE_ARRAY_SIZE];
		for(int i = 0; i < RECEIVE_ARRAY_SIZE; i++)
		{
			receiveArray[i] = 0x00;
		}
		while(i2c_hasData() && (receiveArray[0] != START) )
 390:	99 23       	and	r25, r25
 392:	09 f4       	brne	.+2      	; 0x396 <i2cAPI_checkForPackets+0x68>
 394:	c6 c0       	rjmp	.+396    	; 0x522 <i2cAPI_checkForPackets+0x1f4>
 396:	8b 3a       	cpi	r24, 0xAB	; 171
 398:	a9 f7       	brne	.-22     	; 0x384 <i2cAPI_checkForPackets+0x56>

static uint8_t i2c_GetByteWithTimeout(uint8_t *destination, uint8_t timeout_ms)
{
	while (timeout_ms != 0)
	{
		if(byteQueue.numData)
 39a:	80 91 06 21 	lds	r24, 0x2106
 39e:	88 23       	and	r24, r24
 3a0:	09 f4       	brne	.+2      	; 0x3a4 <i2cAPI_checkForPackets+0x76>
 3a2:	cb c0       	rjmp	.+406    	; 0x53a <i2cAPI_checkForPackets+0x20c>
 3a4:	03 c0       	rjmp	.+6      	; 0x3ac <i2cAPI_checkForPackets+0x7e>
 3a6:	92 81       	ldd	r25, Z+2	; 0x02
 3a8:	99 23       	and	r25, r25
 3aa:	41 f0       	breq	.+16     	; 0x3bc <i2cAPI_checkForPackets+0x8e>
		{
			*destination = byteQueue_deQueue();
 3ac:	0e 94 43 01 	call	0x286	; 0x286 <byteQueue_deQueue>
 3b0:	58 2e       	mov	r5, r24
			//pathTrace++;
			uint8_t length;
			if(i2c_GetByteWithTimeout(&length, 10))
			{
				//pathTrace++;
				receiveArray[1] = length;
 3b2:	8a 83       	std	Y+2, r24	; 0x02
				if(length <= ( RECEIVE_ARRAY_SIZE-2 ) )
 3b4:	b2 e1       	ldi	r27, 0x12	; 18
 3b6:	b8 17       	cp	r27, r24
 3b8:	50 f4       	brcc	.+20     	; 0x3ce <i2cAPI_checkForPackets+0xa0>
 3ba:	ab c0       	rjmp	.+342    	; 0x512 <i2cAPI_checkForPackets+0x1e4>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 3bc:	a3 ef       	ldi	r26, 0xF3	; 243
 3be:	b1 e0       	ldi	r27, 0x01	; 1
 3c0:	11 97       	sbiw	r26, 0x01	; 1
 3c2:	f1 f7       	brne	.-4      	; 0x3c0 <i2cAPI_checkForPackets+0x92>
 3c4:	00 c0       	rjmp	.+0      	; 0x3c6 <i2cAPI_checkForPackets+0x98>
 3c6:	00 00       	nop
 3c8:	81 50       	subi	r24, 0x01	; 1
//	packetQueue.overflowFlag = 0;
//}

static uint8_t i2c_GetByteWithTimeout(uint8_t *destination, uint8_t timeout_ms)
{
	while (timeout_ms != 0)
 3ca:	69 f7       	brne	.-38     	; 0x3a6 <i2cAPI_checkForPackets+0x78>
 3cc:	a2 c0       	rjmp	.+324    	; 0x512 <i2cAPI_checkForPackets+0x1e4>
				receiveArray[1] = length;
				if(length <= ( RECEIVE_ARRAY_SIZE-2 ) )
				{
					//pathTrace++;
					int i;
					for(i = 2; i < length+2; i++)
 3ce:	88 2e       	mov	r8, r24
 3d0:	91 2c       	mov	r9, r1
 3d2:	34 01       	movw	r6, r8
 3d4:	b2 e0       	ldi	r27, 0x02	; 2
 3d6:	6b 0e       	add	r6, r27
 3d8:	71 1c       	adc	r7, r1
 3da:	e3 e0       	ldi	r30, 0x03	; 3
 3dc:	6e 16       	cp	r6, r30
 3de:	71 04       	cpc	r7, r1
 3e0:	04 f5       	brge	.+64     	; 0x422 <i2cAPI_checkForPackets+0xf4>
 3e2:	68 94       	set
 3e4:	ee 24       	eor	r14, r14
 3e6:	e1 f8       	bld	r14, 1
 3e8:	f1 2c       	mov	r15, r1
 3ea:	31 c0       	rjmp	.+98     	; 0x44e <i2cAPI_checkForPackets+0x120>

static uint8_t i2c_GetByteWithTimeout(uint8_t *destination, uint8_t timeout_ms)
{
	while (timeout_ms != 0)
	{
		if(byteQueue.numData)
 3ec:	d8 01       	movw	r26, r16
 3ee:	12 96       	adiw	r26, 0x02	; 2
 3f0:	2c 91       	ld	r18, X
 3f2:	22 23       	and	r18, r18
 3f4:	69 f0       	breq	.+26     	; 0x410 <i2cAPI_checkForPackets+0xe2>
		{
			*destination = byteQueue_deQueue();
 3f6:	0e 94 43 01 	call	0x286	; 0x286 <byteQueue_deQueue>
 3fa:	f6 01       	movw	r30, r12
 3fc:	81 93       	st	Z+, r24
 3fe:	6f 01       	movw	r12, r30
				receiveArray[1] = length;
				if(length <= ( RECEIVE_ARRAY_SIZE-2 ) )
				{
					//pathTrace++;
					int i;
					for(i = 2; i < length+2; i++)
 400:	ff ef       	ldi	r31, 0xFF	; 255
 402:	ef 1a       	sub	r14, r31
 404:	ff 0a       	sbc	r15, r31
 406:	ea 14       	cp	r14, r10
 408:	fb 04       	cpc	r15, r11
 40a:	d1 f4       	brne	.+52     	; 0x440 <i2cAPI_checkForPackets+0x112>
 40c:	75 01       	movw	r14, r10
 40e:	1f c0       	rjmp	.+62     	; 0x44e <i2cAPI_checkForPackets+0x120>
 410:	a3 ef       	ldi	r26, 0xF3	; 243
 412:	b1 e0       	ldi	r27, 0x01	; 1
 414:	11 97       	sbiw	r26, 0x01	; 1
 416:	f1 f7       	brne	.-4      	; 0x414 <i2cAPI_checkForPackets+0xe6>
 418:	00 c0       	rjmp	.+0      	; 0x41a <i2cAPI_checkForPackets+0xec>
 41a:	00 00       	nop
 41c:	91 50       	subi	r25, 0x01	; 1
//	packetQueue.overflowFlag = 0;
//}

static uint8_t i2c_GetByteWithTimeout(uint8_t *destination, uint8_t timeout_ms)
{
	while (timeout_ms != 0)
 41e:	31 f7       	brne	.-52     	; 0x3ec <i2cAPI_checkForPackets+0xbe>
 420:	16 c0       	rjmp	.+44     	; 0x44e <i2cAPI_checkForPackets+0x120>
 422:	6e 01       	movw	r12, r28
 424:	b3 e0       	ldi	r27, 0x03	; 3
 426:	cb 0e       	add	r12, r27
 428:	d1 1c       	adc	r13, r1
 42a:	a8 2e       	mov	r10, r24
 42c:	b1 2c       	mov	r11, r1
 42e:	e2 e0       	ldi	r30, 0x02	; 2
 430:	ae 0e       	add	r10, r30
 432:	b1 1c       	adc	r11, r1
				receiveArray[1] = length;
				if(length <= ( RECEIVE_ARRAY_SIZE-2 ) )
				{
					//pathTrace++;
					int i;
					for(i = 2; i < length+2; i++)
 434:	68 94       	set
 436:	ee 24       	eor	r14, r14
 438:	e1 f8       	bld	r14, 1
 43a:	f1 2c       	mov	r15, r1

static uint8_t i2c_GetByteWithTimeout(uint8_t *destination, uint8_t timeout_ms)
{
	while (timeout_ms != 0)
	{
		if(byteQueue.numData)
 43c:	04 e0       	ldi	r16, 0x04	; 4
 43e:	11 e2       	ldi	r17, 0x21	; 33
 440:	d8 01       	movw	r26, r16
 442:	12 96       	adiw	r26, 0x02	; 2
 444:	9c 91       	ld	r25, X
 446:	99 23       	and	r25, r25
 448:	09 f4       	brne	.+2      	; 0x44c <i2cAPI_checkForPackets+0x11e>
 44a:	6f c0       	rjmp	.+222    	; 0x52a <i2cAPI_checkForPackets+0x1fc>
 44c:	d4 cf       	rjmp	.-88     	; 0x3f6 <i2cAPI_checkForPackets+0xc8>
							//Timed out!
							//timedOut = 1;
							break;
						}
					}
					if(i == length+2)
 44e:	6e 14       	cp	r6, r14
 450:	7f 04       	cpc	r7, r15
 452:	09 f0       	breq	.+2      	; 0x456 <i2cAPI_checkForPackets+0x128>
 454:	5e c0       	rjmp	.+188    	; 0x512 <i2cAPI_checkForPackets+0x1e4>
					{
						//pathTrace++;
						if(receiveArray[length+1] == STOP)
 456:	fe 01       	movw	r30, r28
 458:	e8 0d       	add	r30, r8
 45a:	f9 1d       	adc	r31, r9
 45c:	82 81       	ldd	r24, Z+2	; 0x02
 45e:	8d 3c       	cpi	r24, 0xCD	; 205
 460:	09 f0       	breq	.+2      	; 0x464 <i2cAPI_checkForPackets+0x136>
 462:	57 c0       	rjmp	.+174    	; 0x512 <i2cAPI_checkForPackets+0x1e4>
						{
							//pathTrace++;
							//Calculate parity
							uint8_t parityByte = 0;
							for(int j = 1; j < length; j++)
 464:	b2 e0       	ldi	r27, 0x02	; 2
 466:	8b 16       	cp	r8, r27
 468:	91 04       	cpc	r9, r1
 46a:	7c f0       	brlt	.+30     	; 0x48a <i2cAPI_checkForPackets+0x15c>
 46c:	fe 01       	movw	r30, r28
 46e:	32 96       	adiw	r30, 0x02	; 2
 470:	21 e0       	ldi	r18, 0x01	; 1
 472:	30 e0       	ldi	r19, 0x00	; 0
 474:	2c 0f       	add	r18, r28
 476:	3d 1f       	adc	r19, r29
 478:	25 0d       	add	r18, r5
 47a:	31 1d       	adc	r19, r1
 47c:	80 e0       	ldi	r24, 0x00	; 0
							{
								parityByte ^= receiveArray[j];
 47e:	91 91       	ld	r25, Z+
 480:	89 27       	eor	r24, r25
						if(receiveArray[length+1] == STOP)
						{
							//pathTrace++;
							//Calculate parity
							uint8_t parityByte = 0;
							for(int j = 1; j < length; j++)
 482:	e2 17       	cp	r30, r18
 484:	f3 07       	cpc	r31, r19
 486:	d9 f7       	brne	.-10     	; 0x47e <i2cAPI_checkForPackets+0x150>
 488:	01 c0       	rjmp	.+2      	; 0x48c <i2cAPI_checkForPackets+0x15e>
 48a:	80 e0       	ldi	r24, 0x00	; 0
							{
								parityByte ^= receiveArray[j];
							}

							if(parityByte == receiveArray[length])
 48c:	fe 01       	movw	r30, r28
 48e:	e8 0d       	add	r30, r8
 490:	f9 1d       	adc	r31, r9
 492:	91 81       	ldd	r25, Z+1	; 0x01
 494:	98 13       	cpse	r25, r24
 496:	3d c0       	rjmp	.+122    	; 0x512 <i2cAPI_checkForPackets+0x1e4>
							{
								//Packet is good!
								success = 1;
								packetQueue.packetArray[packetQueue.head].cmd = receiveArray[2];
 498:	20 91 00 20 	lds	r18, 0x2000
 49c:	30 e1       	ldi	r19, 0x10	; 16
 49e:	23 9f       	mul	r18, r19
 4a0:	f0 01       	movw	r30, r0
 4a2:	11 24       	eor	r1, r1
 4a4:	e0 50       	subi	r30, 0x00	; 0
 4a6:	f0 4e       	sbci	r31, 0xE0	; 224
 4a8:	8b 81       	ldd	r24, Y+3	; 0x03
 4aa:	83 83       	std	Z+3, r24	; 0x03

								for(int i = 3; i < length; i++)
 4ac:	84 e0       	ldi	r24, 0x04	; 4
 4ae:	88 16       	cp	r8, r24
 4b0:	91 04       	cpc	r9, r1
 4b2:	9c f0       	brlt	.+38     	; 0x4da <i2cAPI_checkForPackets+0x1ac>
 4b4:	de 01       	movw	r26, r28
 4b6:	14 96       	adiw	r26, 0x04	; 4
 4b8:	e0 e1       	ldi	r30, 0x10	; 16
 4ba:	2e 9f       	mul	r18, r30
 4bc:	c0 01       	movw	r24, r0
 4be:	11 24       	eor	r1, r1
 4c0:	fc 01       	movw	r30, r24
 4c2:	ec 5f       	subi	r30, 0xFC	; 252
 4c4:	ff 4d       	sbci	r31, 0xDF	; 223
 4c6:	01 96       	adiw	r24, 0x01	; 1
 4c8:	85 0d       	add	r24, r5
 4ca:	91 1d       	adc	r25, r1
 4cc:	80 50       	subi	r24, 0x00	; 0
 4ce:	90 4e       	sbci	r25, 0xE0	; 224
								{
									packetQueue.packetArray[packetQueue.head].buffer[i-3] = receiveArray[i];
 4d0:	3d 91       	ld	r19, X+
 4d2:	31 93       	st	Z+, r19
							{
								//Packet is good!
								success = 1;
								packetQueue.packetArray[packetQueue.head].cmd = receiveArray[2];

								for(int i = 3; i < length; i++)
 4d4:	e8 17       	cp	r30, r24
 4d6:	f9 07       	cpc	r31, r25
 4d8:	d9 f7       	brne	.-10     	; 0x4d0 <i2cAPI_checkForPackets+0x1a2>
								{
									packetQueue.packetArray[packetQueue.head].buffer[i-3] = receiveArray[i];
								}

								packetQueue.head++;
 4da:	2f 5f       	subi	r18, 0xFF	; 255
 4dc:	20 93 00 20 	sts	0x2000, r18
								if(packetQueue.head == PACKET_ARRAY_SIZE)
 4e0:	20 31       	cpi	r18, 0x10	; 16
 4e2:	11 f4       	brne	.+4      	; 0x4e8 <i2cAPI_checkForPackets+0x1ba>
								{
									packetQueue.head = 0;
 4e4:	10 92 00 20 	sts	0x2000, r1
								}

								if(packetQueue.numData < PACKET_ARRAY_SIZE)
 4e8:	80 91 02 20 	lds	r24, 0x2002
 4ec:	80 31       	cpi	r24, 0x10	; 16
 4ee:	20 f4       	brcc	.+8      	; 0x4f8 <i2cAPI_checkForPackets+0x1ca>
								{
									packetQueue.numData++;
 4f0:	8f 5f       	subi	r24, 0xFF	; 255
 4f2:	80 93 02 20 	sts	0x2002, r24
 4f6:	2b c0       	rjmp	.+86     	; 0x54e <i2cAPI_checkForPackets+0x220>
								}
								else
								{
									packetQueue.overflowFlag = 1;
 4f8:	e0 e0       	ldi	r30, 0x00	; 0
 4fa:	f0 e2       	ldi	r31, 0x20	; 32
 4fc:	81 e0       	ldi	r24, 0x01	; 1
 4fe:	80 93 03 21 	sts	0x2103, r24
									packetQueue.tail++;
 502:	81 81       	ldd	r24, Z+1	; 0x01
 504:	8f 5f       	subi	r24, 0xFF	; 255
 506:	81 83       	std	Z+1, r24	; 0x01
									if(packetQueue.tail == PACKET_ARRAY_SIZE)
 508:	80 31       	cpi	r24, 0x10	; 16
 50a:	09 f5       	brne	.+66     	; 0x54e <i2cAPI_checkForPackets+0x220>
									{
										packetQueue.tail = 0;
 50c:	10 92 01 20 	sts	0x2001, r1
 510:	1e c0       	rjmp	.+60     	; 0x54e <i2cAPI_checkForPackets+0x220>
}

static void byteQueue_flushQueue()
{
	//Re-Initialize byteQueueVariables
	byteQueue.head = 0;
 512:	e4 e0       	ldi	r30, 0x04	; 4
 514:	f1 e2       	ldi	r31, 0x21	; 33
 516:	10 82       	st	Z, r1
	byteQueue.tail = 0;
 518:	11 82       	std	Z+1, r1	; 0x01
	byteQueue.numData = 0;
 51a:	12 82       	std	Z+2, r1	; 0x02
	byteQueue.overflowFlag = 0;
 51c:	10 92 47 21 	sts	0x2147, r1
 520:	16 c0       	rjmp	.+44     	; 0x54e <i2cAPI_checkForPackets+0x220>
		}
		while(i2c_hasData() && (receiveArray[0] != START) )
		{
			receiveArray[0] = i2c_getByte();
		}
		if(receiveArray[0] == START)
 522:	89 81       	ldd	r24, Y+1	; 0x01
 524:	8b 3a       	cpi	r24, 0xAB	; 171
 526:	a9 f7       	brne	.-22     	; 0x512 <i2cAPI_checkForPackets+0x1e4>
 528:	38 cf       	rjmp	.-400    	; 0x39a <i2cAPI_checkForPackets+0x6c>
 52a:	83 ef       	ldi	r24, 0xF3	; 243
 52c:	91 e0       	ldi	r25, 0x01	; 1
 52e:	01 97       	sbiw	r24, 0x01	; 1
 530:	f1 f7       	brne	.-4      	; 0x52e <i2cAPI_checkForPackets+0x200>
 532:	00 c0       	rjmp	.+0      	; 0x534 <i2cAPI_checkForPackets+0x206>
 534:	00 00       	nop
 536:	99 e0       	ldi	r25, 0x09	; 9
 538:	59 cf       	rjmp	.-334    	; 0x3ec <i2cAPI_checkForPackets+0xbe>
 53a:	a3 ef       	ldi	r26, 0xF3	; 243
 53c:	b1 e0       	ldi	r27, 0x01	; 1
 53e:	11 97       	sbiw	r26, 0x01	; 1
 540:	f1 f7       	brne	.-4      	; 0x53e <i2cAPI_checkForPackets+0x210>
 542:	00 c0       	rjmp	.+0      	; 0x544 <i2cAPI_checkForPackets+0x216>
 544:	00 00       	nop
 546:	89 e0       	ldi	r24, 0x09	; 9

static uint8_t i2c_GetByteWithTimeout(uint8_t *destination, uint8_t timeout_ms)
{
	while (timeout_ms != 0)
	{
		if(byteQueue.numData)
 548:	e4 e0       	ldi	r30, 0x04	; 4
 54a:	f1 e2       	ldi	r31, 0x21	; 33
 54c:	2c cf       	rjmp	.-424    	; 0x3a6 <i2cAPI_checkForPackets+0x78>
		if(!success)
		{
			byteQueue_flushQueue();
		}
	}
}
 54e:	64 96       	adiw	r28, 0x14	; 20
 550:	cd bf       	out	0x3d, r28	; 61
 552:	de bf       	out	0x3e, r29	; 62
 554:	df 91       	pop	r29
 556:	cf 91       	pop	r28
 558:	1f 91       	pop	r17
 55a:	0f 91       	pop	r16
 55c:	ff 90       	pop	r15
 55e:	ef 90       	pop	r14
 560:	df 90       	pop	r13
 562:	cf 90       	pop	r12
 564:	bf 90       	pop	r11
 566:	af 90       	pop	r10
 568:	9f 90       	pop	r9
 56a:	8f 90       	pop	r8
 56c:	7f 90       	pop	r7
 56e:	6f 90       	pop	r6
 570:	5f 90       	pop	r5
 572:	08 95       	ret

00000574 <i2cAPI_hasPacket>:

uint8_t i2cAPI_hasPacket()
{
	return packetQueue.numData;
}
 574:	80 91 02 20 	lds	r24, 0x2002
 578:	08 95       	ret

0000057a <i2cAPI_getPacket>:

uint8_t i2cAPI_getPacket(struct packet *packetDestination)
{
 57a:	cf 93       	push	r28
 57c:	df 93       	push	r29
 57e:	dc 01       	movw	r26, r24
	if(packetQueue.numData == 0)
 580:	80 91 02 20 	lds	r24, 0x2002
 584:	88 23       	and	r24, r24
 586:	e9 f0       	breq	.+58     	; 0x5c2 <i2cAPI_getPacket+0x48>
	{
		return 0;
	}

	*packetDestination = packetQueue.packetArray[packetQueue.tail];
 588:	c0 e0       	ldi	r28, 0x00	; 0
 58a:	d0 e2       	ldi	r29, 0x20	; 32
 58c:	e9 81       	ldd	r30, Y+1	; 0x01
 58e:	80 e1       	ldi	r24, 0x10	; 16
 590:	e8 9f       	mul	r30, r24
 592:	f0 01       	movw	r30, r0
 594:	11 24       	eor	r1, r1
 596:	ed 5f       	subi	r30, 0xFD	; 253
 598:	ff 4d       	sbci	r31, 0xDF	; 223
 59a:	90 e1       	ldi	r25, 0x10	; 16
 59c:	01 90       	ld	r0, Z+
 59e:	0d 92       	st	X+, r0
 5a0:	9a 95       	dec	r25
 5a2:	e1 f7       	brne	.-8      	; 0x59c <i2cAPI_getPacket+0x22>

	packetQueue.tail++;
 5a4:	89 81       	ldd	r24, Y+1	; 0x01
 5a6:	8f 5f       	subi	r24, 0xFF	; 255
	if(packetQueue.tail == PACKET_ARRAY_SIZE)
 5a8:	80 31       	cpi	r24, 0x10	; 16
 5aa:	19 f0       	breq	.+6      	; 0x5b2 <i2cAPI_getPacket+0x38>
		return 0;
	}

	*packetDestination = packetQueue.packetArray[packetQueue.tail];

	packetQueue.tail++;
 5ac:	80 93 01 20 	sts	0x2001, r24
 5b0:	02 c0       	rjmp	.+4      	; 0x5b6 <i2cAPI_getPacket+0x3c>
	if(packetQueue.tail == PACKET_ARRAY_SIZE)
	{
		packetQueue.tail = 0;
 5b2:	10 92 01 20 	sts	0x2001, r1
	}
	packetQueue.numData--;
 5b6:	e0 e0       	ldi	r30, 0x00	; 0
 5b8:	f0 e2       	ldi	r31, 0x20	; 32
 5ba:	82 81       	ldd	r24, Z+2	; 0x02
 5bc:	81 50       	subi	r24, 0x01	; 1
 5be:	82 83       	std	Z+2, r24	; 0x02
	return 1;
 5c0:	81 e0       	ldi	r24, 0x01	; 1
}
 5c2:	df 91       	pop	r29
 5c4:	cf 91       	pop	r28
 5c6:	08 95       	ret

000005c8 <led_init>:
PB2 - CMD
 */

void led_init()
{
	PORTA.OUTSET = 0xFF;
 5c8:	e0 e0       	ldi	r30, 0x00	; 0
 5ca:	f6 e0       	ldi	r31, 0x06	; 6
 5cc:	8f ef       	ldi	r24, 0xFF	; 255
 5ce:	85 83       	std	Z+5, r24	; 0x05
	PORTA.DIRSET = 0xFF;
 5d0:	81 83       	std	Z+1, r24	; 0x01

	PORTB.OUTSET = 0x07;
 5d2:	e0 e2       	ldi	r30, 0x20	; 32
 5d4:	f6 e0       	ldi	r31, 0x06	; 6
 5d6:	87 e0       	ldi	r24, 0x07	; 7
 5d8:	85 83       	std	Z+5, r24	; 0x05
	PORTB.DIRSET = 0x07;
 5da:	81 83       	std	Z+1, r24	; 0x01
 5dc:	08 95       	ret

000005de <led_cmdOn>:
}

void led_cmdOn()
{
	PORTB.OUTCLR = CMD_MASK;
 5de:	84 e0       	ldi	r24, 0x04	; 4
 5e0:	80 93 26 06 	sts	0x0626, r24
 5e4:	08 95       	ret

000005e6 <led_cmdOff>:
}
void led_cmdOff()
{
	PORTB.OUTSET = CMD_MASK;
 5e6:	84 e0       	ldi	r24, 0x04	; 4
 5e8:	80 93 25 06 	sts	0x0625, r24
 5ec:	08 95       	ret

000005ee <led_pingOn>:
	PORTB.OUTTGL = CMD_MASK;
}

void led_pingOn()
{
	PORTB.OUTCLR = PING_MASK;
 5ee:	82 e0       	ldi	r24, 0x02	; 2
 5f0:	80 93 26 06 	sts	0x0626, r24
 5f4:	08 95       	ret

000005f6 <led_pingOff>:
}
void led_pingOff()
{
	PORTB.OUTSET = PING_MASK;
 5f6:	82 e0       	ldi	r24, 0x02	; 2
 5f8:	80 93 25 06 	sts	0x0625, r24
 5fc:	08 95       	ret

000005fe <led_aliveToggle>:
{
	PORTB.OUTSET = ALIVE_MASK;
}
void led_aliveToggle()
{
	PORTB.OUTTGL = ALIVE_MASK;
 5fe:	81 e0       	ldi	r24, 0x01	; 1
 600:	80 93 27 06 	sts	0x0627, r24
 604:	08 95       	ret

00000606 <led_dataOut>:
}

void led_dataOut(uint8_t value)
{
	PORTA.OUT = ~value;
 606:	80 95       	com	r24
 608:	80 93 04 06 	sts	0x0604, r24
 60c:	08 95       	ret

0000060e <TWI_SlaveInitializeDriver>:
 *  \param processDataFunction  Pointer to the function that handles incoming data.
 */
void TWI_SlaveInitializeDriver(TWI_Slave_t *twi,
                               TWI_t *module,
                               void (*processDataFunction) (void))
{
 60e:	fc 01       	movw	r30, r24
	twi->interface = module;
 610:	60 83       	st	Z, r22
 612:	71 83       	std	Z+1, r23	; 0x01
	twi->Process_Data = processDataFunction;
 614:	42 83       	std	Z+2, r20	; 0x02
 616:	53 83       	std	Z+3, r21	; 0x03
	twi->bytesReceived = 0;
 618:	10 a2       	std	Z+32, r1	; 0x20
	twi->bytesSent = 0;
 61a:	11 a2       	std	Z+33, r1	; 0x21
	twi->status = TWIS_STATUS_READY;
 61c:	12 a2       	std	Z+34, r1	; 0x22
	twi->result = TWIS_RESULT_UNKNOWN;
 61e:	13 a2       	std	Z+35, r1	; 0x23
	twi->abort = false;
 620:	14 a2       	std	Z+36, r1	; 0x24
 622:	08 95       	ret

00000624 <TWI_SlaveInitializeModule>:
 */
void TWI_SlaveInitializeModule(TWI_Slave_t *twi,
                               uint8_t address,
                               TWI_SLAVE_INTLVL_t intLevel)
{
	twi->interface->SLAVE.CTRLA = intLevel |
 624:	dc 01       	movw	r26, r24
 626:	ed 91       	ld	r30, X+
 628:	fc 91       	ld	r31, X
 62a:	11 97       	sbiw	r26, 0x01	; 1
 62c:	48 63       	ori	r20, 0x38	; 56
 62e:	40 87       	std	Z+8, r20	; 0x08
	                              TWI_SLAVE_DIEN_bm |
	                              TWI_SLAVE_APIEN_bm |
	                              TWI_SLAVE_ENABLE_bm;
	twi->interface->SLAVE.ADDR = (address<<1);
 630:	ed 91       	ld	r30, X+
 632:	fc 91       	ld	r31, X
 634:	66 0f       	add	r22, r22
 636:	63 87       	std	Z+11, r22	; 0x0b
 638:	08 95       	ret

0000063a <TWI_SlaveAddressMatchHandler>:
 *  Prepares TWI module for transaction when an address match occures.
 *
 *  \param twi The TWI_Slave_t struct instance.
 */
void TWI_SlaveAddressMatchHandler(TWI_Slave_t *twi)
{
 63a:	fc 01       	movw	r30, r24
	/* If application signalling need to abort (error occured). */
	if (twi->abort) {
 63c:	84 a1       	ldd	r24, Z+36	; 0x24
 63e:	88 23       	and	r24, r24
 640:	51 f0       	breq	.+20     	; 0x656 <TWI_SlaveAddressMatchHandler+0x1c>
		twi->interface->SLAVE.CTRLB = TWI_SLAVE_CMD_COMPTRANS_gc;
 642:	a0 81       	ld	r26, Z
 644:	b1 81       	ldd	r27, Z+1	; 0x01
 646:	82 e0       	ldi	r24, 0x02	; 2
 648:	19 96       	adiw	r26, 0x09	; 9
 64a:	8c 93       	st	X, r24
 *  \param twi    The TWI_Slave_t struct instance.
 *  \param result The result of the transaction.
 */
void TWI_SlaveTransactionFinished(TWI_Slave_t *twi, uint8_t result)
{
	twi->result = result;
 64c:	86 e0       	ldi	r24, 0x06	; 6
 64e:	83 a3       	std	Z+35, r24	; 0x23
	twi->status = TWIS_STATUS_READY;
 650:	12 a2       	std	Z+34, r1	; 0x22
{
	/* If application signalling need to abort (error occured). */
	if (twi->abort) {
		twi->interface->SLAVE.CTRLB = TWI_SLAVE_CMD_COMPTRANS_gc;
		TWI_SlaveTransactionFinished(twi, TWIS_RESULT_ABORTED);
		twi->abort = false;
 652:	14 a2       	std	Z+36, r1	; 0x24
 654:	08 95       	ret
	} else {
		twi->status = TWIS_STATUS_BUSY;
 656:	81 e0       	ldi	r24, 0x01	; 1
 658:	82 a3       	std	Z+34, r24	; 0x22
		twi->result = TWIS_RESULT_UNKNOWN;
 65a:	13 a2       	std	Z+35, r1	; 0x23

		/* Disable stop interrupt. */
		uint8_t currentCtrlA = twi->interface->SLAVE.CTRLA;
 65c:	a0 81       	ld	r26, Z
 65e:	b1 81       	ldd	r27, Z+1	; 0x01
 660:	18 96       	adiw	r26, 0x08	; 8
 662:	8c 91       	ld	r24, X
 664:	18 97       	sbiw	r26, 0x08	; 8
		twi->interface->SLAVE.CTRLA = currentCtrlA & ~TWI_SLAVE_PIEN_bm;
 666:	8b 7f       	andi	r24, 0xFB	; 251
 668:	18 96       	adiw	r26, 0x08	; 8
 66a:	8c 93       	st	X, r24

		twi->bytesReceived = 0;
 66c:	10 a2       	std	Z+32, r1	; 0x20
		twi->bytesSent = 0;
 66e:	11 a2       	std	Z+33, r1	; 0x21

		/* Send ACK, wait for data interrupt. */
		twi->interface->SLAVE.CTRLB = TWI_SLAVE_CMD_RESPONSE_gc;
 670:	01 90       	ld	r0, Z+
 672:	f0 81       	ld	r31, Z
 674:	e0 2d       	mov	r30, r0
 676:	83 e0       	ldi	r24, 0x03	; 3
 678:	81 87       	std	Z+9, r24	; 0x09
 67a:	08 95       	ret

0000067c <TWI_SlaveStopHandler>:
/*! \brief TWI stop condition interrupt handler.
 *
 *  \param twi The TWI_Slave_t struct instance.
 */
void TWI_SlaveStopHandler(TWI_Slave_t *twi)
{
 67c:	fc 01       	movw	r30, r24
	/* Disable stop interrupt. */
	uint8_t currentCtrlA = twi->interface->SLAVE.CTRLA;
 67e:	a0 81       	ld	r26, Z
 680:	b1 81       	ldd	r27, Z+1	; 0x01
 682:	18 96       	adiw	r26, 0x08	; 8
 684:	8c 91       	ld	r24, X
 686:	18 97       	sbiw	r26, 0x08	; 8
	twi->interface->SLAVE.CTRLA = currentCtrlA & ~TWI_SLAVE_PIEN_bm;
 688:	8b 7f       	andi	r24, 0xFB	; 251
 68a:	18 96       	adiw	r26, 0x08	; 8
 68c:	8c 93       	st	X, r24
	
	/* Clear APIF, according to flowchart don't ACK or NACK */
	uint8_t currentStatus = twi->interface->SLAVE.STATUS;
 68e:	a0 81       	ld	r26, Z
 690:	b1 81       	ldd	r27, Z+1	; 0x01
 692:	1a 96       	adiw	r26, 0x0a	; 10
 694:	8c 91       	ld	r24, X
 696:	1a 97       	sbiw	r26, 0x0a	; 10
	twi->interface->SLAVE.STATUS = currentStatus | TWI_SLAVE_APIF_bm;
 698:	80 64       	ori	r24, 0x40	; 64
 69a:	1a 96       	adiw	r26, 0x0a	; 10
 69c:	8c 93       	st	X, r24
 *  \param twi    The TWI_Slave_t struct instance.
 *  \param result The result of the transaction.
 */
void TWI_SlaveTransactionFinished(TWI_Slave_t *twi, uint8_t result)
{
	twi->result = result;
 69e:	81 e0       	ldi	r24, 0x01	; 1
 6a0:	83 a3       	std	Z+35, r24	; 0x23
	twi->status = TWIS_STATUS_READY;
 6a2:	12 a2       	std	Z+34, r1	; 0x22
 6a4:	08 95       	ret

000006a6 <TWI_SlaveReadHandler>:
 *  Handles TWI slave read transactions and responses.
 *
 *  \param twi The TWI_Slave_t struct instance.
 */
void TWI_SlaveReadHandler(TWI_Slave_t *twi)
{
 6a6:	cf 93       	push	r28
 6a8:	df 93       	push	r29
 6aa:	fc 01       	movw	r30, r24
	/* Enable stop interrupt. */
	uint8_t currentCtrlA = twi->interface->SLAVE.CTRLA;
 6ac:	a0 81       	ld	r26, Z
 6ae:	b1 81       	ldd	r27, Z+1	; 0x01
 6b0:	18 96       	adiw	r26, 0x08	; 8
 6b2:	8c 91       	ld	r24, X
 6b4:	18 97       	sbiw	r26, 0x08	; 8
	twi->interface->SLAVE.CTRLA = currentCtrlA | TWI_SLAVE_PIEN_bm;
 6b6:	84 60       	ori	r24, 0x04	; 4
 6b8:	18 96       	adiw	r26, 0x08	; 8
 6ba:	8c 93       	st	X, r24

	/* If free space in buffer. */
	if (twi->bytesReceived < TWIS_RECEIVE_BUFFER_SIZE) {
 6bc:	80 a1       	ldd	r24, Z+32	; 0x20
 6be:	88 30       	cpi	r24, 0x08	; 8
 6c0:	08 f5       	brcc	.+66     	; 0x704 <TWI_SlaveReadHandler+0x5e>
 6c2:	ef 01       	movw	r28, r30
		/* Fetch data */
		uint8_t data = twi->interface->SLAVE.DATA;
 6c4:	01 90       	ld	r0, Z+
 6c6:	f0 81       	ld	r31, Z
 6c8:	e0 2d       	mov	r30, r0
 6ca:	84 85       	ldd	r24, Z+12	; 0x0c
		twi->receivedData[twi->bytesReceived] = data;
 6cc:	98 a1       	ldd	r25, Y+32	; 0x20
 6ce:	fe 01       	movw	r30, r28
 6d0:	e9 0f       	add	r30, r25
 6d2:	f1 1d       	adc	r31, r1
 6d4:	84 83       	std	Z+4, r24	; 0x04

		/* Process data. */
		twi->Process_Data();
 6d6:	ea 81       	ldd	r30, Y+2	; 0x02
 6d8:	fb 81       	ldd	r31, Y+3	; 0x03
 6da:	19 95       	eicall

		twi->bytesReceived++;
 6dc:	88 a1       	ldd	r24, Y+32	; 0x20
 6de:	8f 5f       	subi	r24, 0xFF	; 255
 6e0:	88 a3       	std	Y+32, r24	; 0x20

		/* If application signalling need to abort (error occured),
		 * complete transaction and wait for next START. Otherwise
		 * send ACK and wait for data interrupt.
		 */
		if (twi->abort) {
 6e2:	8c a1       	ldd	r24, Y+36	; 0x24
 6e4:	88 23       	and	r24, r24
 6e6:	49 f0       	breq	.+18     	; 0x6fa <TWI_SlaveReadHandler+0x54>
			twi->interface->SLAVE.CTRLB = TWI_SLAVE_CMD_COMPTRANS_gc;
 6e8:	e8 81       	ld	r30, Y
 6ea:	f9 81       	ldd	r31, Y+1	; 0x01
 6ec:	82 e0       	ldi	r24, 0x02	; 2
 6ee:	81 87       	std	Z+9, r24	; 0x09
 *  \param twi    The TWI_Slave_t struct instance.
 *  \param result The result of the transaction.
 */
void TWI_SlaveTransactionFinished(TWI_Slave_t *twi, uint8_t result)
{
	twi->result = result;
 6f0:	86 e0       	ldi	r24, 0x06	; 6
 6f2:	8b a3       	std	Y+35, r24	; 0x23
	twi->status = TWIS_STATUS_READY;
 6f4:	1a a2       	std	Y+34, r1	; 0x22
		 * send ACK and wait for data interrupt.
		 */
		if (twi->abort) {
			twi->interface->SLAVE.CTRLB = TWI_SLAVE_CMD_COMPTRANS_gc;
			TWI_SlaveTransactionFinished(twi, TWIS_RESULT_ABORTED);
			twi->abort = false;
 6f6:	1c a2       	std	Y+36, r1	; 0x24
 6f8:	0d c0       	rjmp	.+26     	; 0x714 <TWI_SlaveReadHandler+0x6e>
		} else {
			twi->interface->SLAVE.CTRLB = TWI_SLAVE_CMD_RESPONSE_gc;
 6fa:	e8 81       	ld	r30, Y
 6fc:	f9 81       	ldd	r31, Y+1	; 0x01
 6fe:	83 e0       	ldi	r24, 0x03	; 3
 700:	81 87       	std	Z+9, r24	; 0x09
 702:	08 c0       	rjmp	.+16     	; 0x714 <TWI_SlaveReadHandler+0x6e>
	}
	/* If buffer overflow, send NACK and wait for next START. Set
	 * result buffer overflow.
	 */
	else {
		twi->interface->SLAVE.CTRLB = TWI_SLAVE_ACKACT_bm |
 704:	a0 81       	ld	r26, Z
 706:	b1 81       	ldd	r27, Z+1	; 0x01
 708:	86 e0       	ldi	r24, 0x06	; 6
 70a:	19 96       	adiw	r26, 0x09	; 9
 70c:	8c 93       	st	X, r24
 *  \param twi    The TWI_Slave_t struct instance.
 *  \param result The result of the transaction.
 */
void TWI_SlaveTransactionFinished(TWI_Slave_t *twi, uint8_t result)
{
	twi->result = result;
 70e:	82 e0       	ldi	r24, 0x02	; 2
 710:	83 a3       	std	Z+35, r24	; 0x23
	twi->status = TWIS_STATUS_READY;
 712:	12 a2       	std	Z+34, r1	; 0x22
	else {
		twi->interface->SLAVE.CTRLB = TWI_SLAVE_ACKACT_bm |
		                              TWI_SLAVE_CMD_COMPTRANS_gc;
		TWI_SlaveTransactionFinished(twi, TWIS_RESULT_BUFFER_OVERFLOW);
	}
}
 714:	df 91       	pop	r29
 716:	cf 91       	pop	r28
 718:	08 95       	ret

0000071a <TWI_SlaveWriteHandler>:
 *  Handles TWI slave write transactions and responses.
 *
 *  \param twi The TWI_Slave_t struct instance.
 */
void TWI_SlaveWriteHandler(TWI_Slave_t *twi)
{
 71a:	fc 01       	movw	r30, r24
	/* If NACK, slave write transaction finished. */
	if ((twi->bytesSent > 0) && (twi->interface->SLAVE.STATUS &
 71c:	81 a1       	ldd	r24, Z+33	; 0x21
 71e:	88 23       	and	r24, r24
 720:	71 f0       	breq	.+28     	; 0x73e <TWI_SlaveWriteHandler+0x24>
 722:	a0 81       	ld	r26, Z
 724:	b1 81       	ldd	r27, Z+1	; 0x01
 726:	1a 96       	adiw	r26, 0x0a	; 10
 728:	8c 91       	ld	r24, X
 72a:	1a 97       	sbiw	r26, 0x0a	; 10
 72c:	84 ff       	sbrs	r24, 4
 72e:	07 c0       	rjmp	.+14     	; 0x73e <TWI_SlaveWriteHandler+0x24>
	                             TWI_SLAVE_RXACK_bm)) {

		twi->interface->SLAVE.CTRLB = TWI_SLAVE_CMD_COMPTRANS_gc;
 730:	82 e0       	ldi	r24, 0x02	; 2
 732:	19 96       	adiw	r26, 0x09	; 9
 734:	8c 93       	st	X, r24
 *  \param twi    The TWI_Slave_t struct instance.
 *  \param result The result of the transaction.
 */
void TWI_SlaveTransactionFinished(TWI_Slave_t *twi, uint8_t result)
{
	twi->result = result;
 736:	81 e0       	ldi	r24, 0x01	; 1
 738:	83 a3       	std	Z+35, r24	; 0x23
	twi->status = TWIS_STATUS_READY;
 73a:	12 a2       	std	Z+34, r1	; 0x22
 73c:	08 95       	ret
		twi->interface->SLAVE.CTRLB = TWI_SLAVE_CMD_COMPTRANS_gc;
		TWI_SlaveTransactionFinished(twi, TWIS_RESULT_OK);
	}
	/* If ACK, master expects more data. */
	else {
		if (twi->bytesSent < TWIS_SEND_BUFFER_SIZE) {
 73e:	81 a1       	ldd	r24, Z+33	; 0x21
 740:	84 31       	cpi	r24, 0x14	; 20
 742:	98 f4       	brcc	.+38     	; 0x76a <TWI_SlaveWriteHandler+0x50>
			uint8_t data = twi->sendData[twi->bytesSent];
 744:	81 a1       	ldd	r24, Z+33	; 0x21
 746:	df 01       	movw	r26, r30
 748:	a8 0f       	add	r26, r24
 74a:	b1 1d       	adc	r27, r1
 74c:	1c 96       	adiw	r26, 0x0c	; 12
 74e:	8c 91       	ld	r24, X
			twi->interface->SLAVE.DATA = data;
 750:	a0 81       	ld	r26, Z
 752:	b1 81       	ldd	r27, Z+1	; 0x01
 754:	1c 96       	adiw	r26, 0x0c	; 12
 756:	8c 93       	st	X, r24
			twi->bytesSent++;
 758:	81 a1       	ldd	r24, Z+33	; 0x21
 75a:	8f 5f       	subi	r24, 0xFF	; 255
 75c:	81 a3       	std	Z+33, r24	; 0x21

			/* Send data, wait for data interrupt. */
			twi->interface->SLAVE.CTRLB = TWI_SLAVE_CMD_RESPONSE_gc;
 75e:	01 90       	ld	r0, Z+
 760:	f0 81       	ld	r31, Z
 762:	e0 2d       	mov	r30, r0
 764:	83 e0       	ldi	r24, 0x03	; 3
 766:	81 87       	std	Z+9, r24	; 0x09
 768:	08 95       	ret
		}
		/* If buffer overflow. */
		else {
			twi->interface->SLAVE.CTRLB = TWI_SLAVE_CMD_COMPTRANS_gc;
 76a:	a0 81       	ld	r26, Z
 76c:	b1 81       	ldd	r27, Z+1	; 0x01
 76e:	82 e0       	ldi	r24, 0x02	; 2
 770:	19 96       	adiw	r26, 0x09	; 9
 772:	8c 93       	st	X, r24
 *  \param twi    The TWI_Slave_t struct instance.
 *  \param result The result of the transaction.
 */
void TWI_SlaveTransactionFinished(TWI_Slave_t *twi, uint8_t result)
{
	twi->result = result;
 774:	83 a3       	std	Z+35, r24	; 0x23
	twi->status = TWIS_STATUS_READY;
 776:	12 a2       	std	Z+34, r1	; 0x22
 778:	08 95       	ret

0000077a <TWI_SlaveDataHandler>:
 *
 *  \param twi The TWI_Slave_t struct instance.
 */
void TWI_SlaveDataHandler(TWI_Slave_t *twi)
{
	if (twi->interface->SLAVE.STATUS & TWI_SLAVE_DIR_bm) {
 77a:	dc 01       	movw	r26, r24
 77c:	ed 91       	ld	r30, X+
 77e:	fc 91       	ld	r31, X
 780:	22 85       	ldd	r18, Z+10	; 0x0a
 782:	21 ff       	sbrs	r18, 1
 784:	03 c0       	rjmp	.+6      	; 0x78c <TWI_SlaveDataHandler+0x12>
		TWI_SlaveWriteHandler(twi);
 786:	0e 94 8d 03 	call	0x71a	; 0x71a <TWI_SlaveWriteHandler>
 78a:	08 95       	ret
	} else {
		TWI_SlaveReadHandler(twi);
 78c:	0e 94 53 03 	call	0x6a6	; 0x6a6 <TWI_SlaveReadHandler>
 790:	08 95       	ret

00000792 <TWI_SlaveInterruptHandler>:
 *  data transmission, bus error and data collision.
 *
 *  \param twi The TWI_Slave_t struct instance.
 */
void TWI_SlaveInterruptHandler(TWI_Slave_t *twi)
{
 792:	fc 01       	movw	r30, r24
	uint8_t currentStatus = twi->interface->SLAVE.STATUS;
 794:	a0 81       	ld	r26, Z
 796:	b1 81       	ldd	r27, Z+1	; 0x01
 798:	1a 96       	adiw	r26, 0x0a	; 10
 79a:	8c 91       	ld	r24, X

	/* If bus error. */
	if (currentStatus & TWI_SLAVE_BUSERR_bm) {
 79c:	82 ff       	sbrs	r24, 2
 79e:	06 c0       	rjmp	.+12     	; 0x7ac <TWI_SlaveInterruptHandler+0x1a>
		twi->bytesReceived = 0;
 7a0:	10 a2       	std	Z+32, r1	; 0x20
		twi->bytesSent = 0;
 7a2:	11 a2       	std	Z+33, r1	; 0x21
		twi->result = TWIS_RESULT_BUS_ERROR;
 7a4:	84 e0       	ldi	r24, 0x04	; 4
 7a6:	83 a3       	std	Z+35, r24	; 0x23
		twi->status = TWIS_STATUS_READY;
 7a8:	12 a2       	std	Z+34, r1	; 0x22
 7aa:	08 95       	ret
	}

	/* If transmit collision. */
	else if (currentStatus & TWI_SLAVE_COLL_bm) {
 7ac:	83 ff       	sbrs	r24, 3
 7ae:	06 c0       	rjmp	.+12     	; 0x7bc <TWI_SlaveInterruptHandler+0x2a>
		twi->bytesReceived = 0;
 7b0:	10 a2       	std	Z+32, r1	; 0x20
		twi->bytesSent = 0;
 7b2:	11 a2       	std	Z+33, r1	; 0x21
		twi->result = TWIS_RESULT_TRANSMIT_COLLISION;
 7b4:	83 e0       	ldi	r24, 0x03	; 3
 7b6:	83 a3       	std	Z+35, r24	; 0x23
		twi->status = TWIS_STATUS_READY;
 7b8:	12 a2       	std	Z+34, r1	; 0x22
 7ba:	08 95       	ret
	}

	/* If address match. */
	else if ((currentStatus & TWI_SLAVE_APIF_bm) &&
 7bc:	28 2f       	mov	r18, r24
 7be:	20 74       	andi	r18, 0x40	; 64
 7c0:	98 2f       	mov	r25, r24
 7c2:	91 74       	andi	r25, 0x41	; 65
 7c4:	91 34       	cpi	r25, 0x41	; 65
 7c6:	21 f4       	brne	.+8      	; 0x7d0 <TWI_SlaveInterruptHandler+0x3e>
	        (currentStatus & TWI_SLAVE_AP_bm)) {

		TWI_SlaveAddressMatchHandler(twi);
 7c8:	cf 01       	movw	r24, r30
 7ca:	0e 94 1d 03 	call	0x63a	; 0x63a <TWI_SlaveAddressMatchHandler>
 7ce:	08 95       	ret
	}

	/* If stop (only enabled through slave read transaction). */
	else if (currentStatus & TWI_SLAVE_APIF_bm) {
 7d0:	22 23       	and	r18, r18
 7d2:	21 f0       	breq	.+8      	; 0x7dc <TWI_SlaveInterruptHandler+0x4a>
		TWI_SlaveStopHandler(twi);
 7d4:	cf 01       	movw	r24, r30
 7d6:	0e 94 3e 03 	call	0x67c	; 0x67c <TWI_SlaveStopHandler>
 7da:	08 95       	ret
	}

	/* If data interrupt. */
	else if (currentStatus & TWI_SLAVE_DIF_bm) {
 7dc:	88 23       	and	r24, r24
 7de:	24 f4       	brge	.+8      	; 0x7e8 <TWI_SlaveInterruptHandler+0x56>
		TWI_SlaveDataHandler(twi);
 7e0:	cf 01       	movw	r24, r30
 7e2:	0e 94 bd 03 	call	0x77a	; 0x77a <TWI_SlaveDataHandler>
 7e6:	08 95       	ret
 *  \param twi    The TWI_Slave_t struct instance.
 *  \param result The result of the transaction.
 */
void TWI_SlaveTransactionFinished(TWI_Slave_t *twi, uint8_t result)
{
	twi->result = result;
 7e8:	85 e0       	ldi	r24, 0x05	; 5
 7ea:	83 a3       	std	Z+35, r24	; 0x23
	twi->status = TWIS_STATUS_READY;
 7ec:	12 a2       	std	Z+34, r1	; 0x22
 7ee:	08 95       	ret

000007f0 <main>:
#include "led.h"
#include "i2cAPI.h"


int main(void)
{
 7f0:	cf 93       	push	r28
 7f2:	df 93       	push	r29
 7f4:	cd b7       	in	r28, 0x3d	; 61
 7f6:	de b7       	in	r29, 0x3e	; 62
 7f8:	60 97       	sbiw	r28, 0x10	; 16
 7fa:	cd bf       	out	0x3d, r28	; 61
 7fc:	de bf       	out	0x3e, r29	; 62
    led_init();
 7fe:	0e 94 e4 02 	call	0x5c8	; 0x5c8 <led_init>
	i2cAPI_init(ADDRESS);
 802:	86 e0       	ldi	r24, 0x06	; 6
 804:	0e 94 85 01 	call	0x30a	; 0x30a <i2cAPI_init>
	
	PMIC.CTRL |= PMIC_LOLVLEN_bm;
 808:	e0 ea       	ldi	r30, 0xA0	; 160
 80a:	f0 e0       	ldi	r31, 0x00	; 0
 80c:	82 81       	ldd	r24, Z+2	; 0x02
 80e:	81 60       	ori	r24, 0x01	; 1
 810:	82 83       	std	Z+2, r24	; 0x02
	sei();
 812:	78 94       	sei
	
	uint8_t aliveCounter = 50;
	uint8_t cmdCounter = 0;
 814:	00 e0       	ldi	r16, 0x00	; 0
	i2cAPI_init(ADDRESS);
	
	PMIC.CTRL |= PMIC_LOLVLEN_bm;
	sei();
	
	uint8_t aliveCounter = 50;
 816:	12 e3       	ldi	r17, 0x32	; 50
	uint8_t cmdCounter = 0;

    while (1) 
    {
		i2cAPI_checkForPackets();
 818:	0e 94 97 01 	call	0x32e	; 0x32e <i2cAPI_checkForPackets>
		if(i2cAPI_hasPacket())
 81c:	0e 94 ba 02 	call	0x574	; 0x574 <i2cAPI_hasPacket>
 820:	88 23       	and	r24, r24
 822:	b9 f0       	breq	.+46     	; 0x852 <main+0x62>
		{
			struct packet receivedPacket;
			i2cAPI_getPacket(&receivedPacket);
 824:	ce 01       	movw	r24, r28
 826:	01 96       	adiw	r24, 0x01	; 1
 828:	0e 94 bd 02 	call	0x57a	; 0x57a <i2cAPI_getPacket>

			switch(receivedPacket.cmd)
 82c:	89 81       	ldd	r24, Y+1	; 0x01
 82e:	82 30       	cpi	r24, 0x02	; 2
 830:	39 f0       	breq	.+14     	; 0x840 <main+0x50>
 832:	83 30       	cpi	r24, 0x03	; 3
 834:	41 f0       	breq	.+16     	; 0x846 <main+0x56>
 836:	81 30       	cpi	r24, 0x01	; 1
 838:	61 f4       	brne	.+24     	; 0x852 <main+0x62>
			{
				case CMD_PING_ON:
					led_pingOn();
 83a:	0e 94 f7 02 	call	0x5ee	; 0x5ee <led_pingOn>
					break;
 83e:	09 c0       	rjmp	.+18     	; 0x852 <main+0x62>
				case CMD_PING_OFF:
					led_pingOff();
 840:	0e 94 fb 02 	call	0x5f6	; 0x5f6 <led_pingOff>
					break;
 844:	06 c0       	rjmp	.+12     	; 0x852 <main+0x62>
				case CMD_DATA:
					led_cmdOn();
 846:	0e 94 ef 02 	call	0x5de	; 0x5de <led_cmdOn>
					cmdCounter = 10;
					led_dataOut(receivedPacket.buffer[0]);
 84a:	8a 81       	ldd	r24, Y+2	; 0x02
 84c:	0e 94 03 03 	call	0x606	; 0x606 <led_dataOut>
				case CMD_PING_OFF:
					led_pingOff();
					break;
				case CMD_DATA:
					led_cmdOn();
					cmdCounter = 10;
 850:	0a e0       	ldi	r16, 0x0A	; 10
					//Bad command
					break;
			}
		}

		aliveCounter--;
 852:	11 50       	subi	r17, 0x01	; 1
		if(aliveCounter == 0)
 854:	19 f4       	brne	.+6      	; 0x85c <main+0x6c>
		{
			led_aliveToggle();
 856:	0e 94 ff 02 	call	0x5fe	; 0x5fe <led_aliveToggle>
			aliveCounter = 50;
 85a:	12 e3       	ldi	r17, 0x32	; 50
		}
		if(cmdCounter != 0)
 85c:	00 23       	and	r16, r16
 85e:	21 f0       	breq	.+8      	; 0x868 <main+0x78>
		{
			cmdCounter--;
 860:	01 50       	subi	r16, 0x01	; 1
			if(cmdCounter == 0)
 862:	11 f4       	brne	.+4      	; 0x868 <main+0x78>
			{
				led_cmdOff();
 864:	0e 94 f3 02 	call	0x5e6	; 0x5e6 <led_cmdOff>
 868:	87 e8       	ldi	r24, 0x87	; 135
 86a:	93 e1       	ldi	r25, 0x13	; 19
 86c:	01 97       	sbiw	r24, 0x01	; 1
 86e:	f1 f7       	brne	.-4      	; 0x86c <main+0x7c>
 870:	00 c0       	rjmp	.+0      	; 0x872 <main+0x82>
 872:	00 00       	nop
 874:	d1 cf       	rjmp	.-94     	; 0x818 <main+0x28>

00000876 <_exit>:
 876:	f8 94       	cli

00000878 <__stop_program>:
 878:	ff cf       	rjmp	.-2      	; 0x878 <__stop_program>
